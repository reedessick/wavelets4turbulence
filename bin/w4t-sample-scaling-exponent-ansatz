#!/usr/bin/env python3

"""a simple executable to fit the She-Leveque parameterization for scaling exponents from structure functions
"""
__author__ = "Reed Essick (reed.essick@gmail.com)"

#-------------------------------------------------

import numpy as np
from jax import numpy as jnp

from argparse import ArgumentParser

### non-standard libraries
from w4t.utils import io
from w4t.utils import infer

#-------------------------------------------------

parser = ArgumentParser()

parser.add_argument('source', type=str)
parser.add_argument('target', type=str)

parser.add_argument('ref_scale', type=float, nargs='+',
    help='the reference scale at which the logarithmic derivative will be evaluated')

parser.add_argument('-m', '--min-scale', default=0.0, type=float,
    help='only include scales > min_scale within the fit')
parser.add_argument('-M', '--max-scale', default=np.inf, type=float,
    help='only include scales < max_scale within the fit')

parser.add_argument('-i', '--index', nargs='*', type=int, default=None,
    help='only fit these indexes. eg: --index 1 2 3')

parser.add_argument('--num-warmup', default=infer.DEFAULT_NUM_WARMUP, type=int)
parser.add_argument('--num-samples', default=infer.DEFAULT_NUM_SAMPLES, type=int)

parser.add_argument('--num-retained', default=infer.DEFAULT_NUM_RETAINED, type=int)

parser.add_argument('--seed', default=infer.DEFAULT_SEED, type=int)

parser.add_argument('-v', '--verbose', default=False, action='store_true')

args = parser.parse_args()

if len(args.ref_scale) == 1:
    args.ref_scale = args.ref_scale[0]

elif len(args.ref_scale) == 2:
    args.ref_scale = sorted(args.ref_scale) # smallest to largest

else:
    raise ValueError('ref_scale=%s not understood!' % args.ref_scale)

#-------------------------------------------------

# load structure functions
scales, indexes, mom, cov = io.load_structure_function(args.source, verbose=args.verbose)

if args.index is not None:
    keep = np.array([(index in args.index) for index in indexes], dtype=bool)
    assert np.any(keep), 'no indexes from (%s) retained in --index=%s' % (indexes, args.index)

    # only keep the requested indexes
    indexes = indexes[keep]
    mom = mom[:,keep]
    cov = cov[:,keep,:][:,:,keep]

#-----------

# compute scaling exponents

min_scale = max(args.min_scale, np.min(scales))
max_scale = min(args.max_scale, np.max(scales))

if args.verbose:
    print('computing scaling exponent with scales between %.3f - %.3f' % \
        (min_scale, max_scale))

sel = (min_scale <= scales) * (scales <= max_scale)

logamp = jnp.log(mom[sel,:])[np.argmin(scales[sel])]

if args.verbose:
    print('sampling She-Leveque parametrization for scaling exponents with\n    ref_scale: %s\n    indexes: %s' % (args.ref_scale, indexes))

posterior, prior = infer.sample_scaling_exponent_ansatz(
    jnp.array(scales[sel]),
    jnp.array(mom[sel]), # (num_scales, num_ind)
    jnp.array(cov[sel]), # (num_scales, num_ind, num_ind)
    indexes,
    args.ref_scale,
    mean_logamp=logamp,
    stdv_logamp=1.0,
    num_warmup=args.num_warmup,
    num_samples=args.num_samples,
    num_retained=args.num_retained,
    seed=args.seed,
    verbose=args.verbose,
)

#-----------

# save scaling exponents
io.write_scaling_exponent_ansatz_samples(
    posterior,
    prior,
    scales,
    indexes,
    args.ref_scale,
    args.target,
    verbose=args.verbose,
    source=args.source,
    min_scale=min_scale,
    max_scale=max_scale,
    num_warmup=args.num_warmup,
    num_sapmles=args.num_samples,
    num_retained=args.num_retained,
    seed=args.seed,
)

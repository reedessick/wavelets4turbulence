#!/usr/bin/env python3

"""a magical script to identify X and O points
"""
__author__ = "Reed Essick (reed.essick@gmail.com)"

#-------------------------------------------------

import os

import numpy as np
import matplotlib
matplotlib.use("Agg")
from matplotlib import pyplot as plt

from argparse import ArgumentParser

### non-standard libraries
from w4t import pywt
from w4t.plot import plane as plt

from w4t.utils import dv # PLASMAtools.aux_funcs.derived_var_funcs

#-------------------------------------------------

x_logmag_thr = -1.50
x_logo_thr   = +1.25

o_logmag_thr = -0.75
o_logo_thr   = +1.00

#-------------------------------------------------

def extrema(data):
    """find local extrema neglecting pixels at the edge of the simulation
    """
    mins = np.ones((nx, ny), dtype=bool)
    maxs = np.ones((nx, ny), dtype=bool)

    mins[0,:] = mins[-1,:] = mins[:,0] = mins[:,-1] = False # exclude edge points
    maxs[0,:] = maxs[-1,:] = maxs[:,0] = maxs[:,-1] = False

    for i in range(nx-2): # look for local minima in the x-direction
        mins[i+1,:] *= (data[i,:] > data[i+1,:])*(data[i+1,:] < data[i+2,:]) # check x derivative
        maxs[i+1,:] *= (data[i,:] < data[i+1,:])*(data[i+1,:] > data[i+2,:])

    for j in range(ny-2): # look for local minima in the y-direction
        mins[:,j+1] *= (data[:,j] > data[:,j+1])*(data[:,j+1] < data[:,j+2])
        maxs[:,j+1] *= (data[:,j] < data[:,j+1])*(data[:,j+1] > data[:,j+2])

    low = np.arange(0, nx-2)
    mid = low+1
    hgh = mid+1
    for i in range(nx-2): # look for local minima along diagonals
        mins[i+1,mid] *= (data[i,low] > data[i+1,mid])*(data[i+1,mid] < data[i+2,hgh]) # check diagonal
        mins[i+1,mid] *= (data[i,hgh] > data[i+1,mid])*(data[i+1,mid] < data[i+2,low]) # check diagonal

        maxs[i+1,mid] *= (data[i,low] < data[i+1,mid])*(data[i+1,mid] > data[i+2,hgh]) # check diagonal
        maxs[i+1,mid] *= (data[i,hgh] < data[i+1,mid])*(data[i+1,mid] > data[i+2,low]) # check diagonal

    return mins, maxs

#------------------------

def imshow(curr, curr_denoise, mag, mag0, mag1, o, div, det, mins, maxs, aspect='auto'):
    fig = plt.plt.figure(figsize=(15,5))

    sel = np.abs(curr_denoise) > 0

    #---

    logcurr = np.log10(np.abs(curr))
#    logcurr_vmax = None
#    logcurr_vmin = None
    logcurr_vmax = np.max(logcurr)
    logcurr_vmin = max(np.min(logcurr), logcurr_vmax-3)

    logcurr_denoise = np.log10(np.abs(curr_denoise))

    logmag = np.log10(np.abs(mag))
#    logmag_vmax = None
#    logmag_vmin = None
    logmag_vmax = np.max(logmag)
    logmag_vmin = max(np.min(logmag), logmag_vmax-3)

    logdiv = np.log10(np.abs(div)) - logmag # normalize this
    logdiv_vmax = None
    logdiv_vmin = None

    sgndet = np.sign(det)
    sgndet_vmax = 1
    sgndet_vmin = -1

#    logdet = np.log10(np.abs(det))
#    logdet_vmax = None
#    logdet_vmin = None
#    logdet_vmax = np.max(np.abs(logdet))
#    logdet_vmin = max(np.min(logdet), logdet_vmax-3)

    bx_vmax = +1
    bx_vmin = -1

    by_vmax = +1
    by_vmin = -1

#    logo = np.log10(o)
    logo = o # FIXME: just for testing
    logo_vmin = None
    logo_vmax = None
#    logo_vmin = np.min(logo[logo==logo]) # be careful about nans
#    logo_vmax = min(np.max(logo[logo==logo]), logo_vmin+5)

    #---

    for ind, (label, cmap, data, ect, vmin, vmax) in enumerate([
            ('$\log|j|$', 'Greys', logcurr, np.ones_like(curr, dtype=bool), logcurr_vmin, logcurr_vmax),
#            ('$\log|\sum_i \partial_i B_i| - \log|B|$', 'YlGn_r', logdiv, np.ones_like(logdiv, dtype=bool), logdiv_vmin, logdiv_vmax),
#            ('$\log|\mathrm{det}|\partial_i B_j||$', 'YlGn_r', logdet, np.ones_like(logdet, dtype=bool), logdet_vmin, logdet_vmax),
#            ('$\mathrm{sgn}(\mathrm{det}|\partial_i B_j|)$', 'PuOr', sgndet, np.ones_like(sgndet, dtype=bool), sgndet_vmin, sgndet_vmax),
            ('$B_y/|B|$', 'RdBu', mag0/mag, np.ones_like(mag0, dtype=bool), by_vmin, by_vmax),
            ('$B_x/|B|$', 'RdBu', mag1/mag, np.ones_like(mag1, dtype=bool), bx_vmin, bx_vmax),
            ('$\log o$', 'Greys', logo, np.ones_like(o, dtype=bool), logo_vmin, logo_vmax),
            ('$\log|B|$', 'vanimo', logmag, np.ones_like(mag, dtype=bool), logmag_vmin, logmag_vmax),
            (None, 'Greys', logcurr_denoise, np.ones_like(curr_denoise, dtype=bool), logcurr_vmin, logcurr_vmax),
#            (None, 'YlGn_r', logdiv, sel, logdiv_vmin, logdiv_vmax),
#            (None, 'YlGn_r', logdet, sel, logdet_vmin, logdet_vmax),
#            (None, 'PuOr', sgndet, sel, sgndet_vmin, sgndet_vmax),
            (None, 'RdBu', mag0/mag, sel, by_vmin, by_vmax),
            (None, 'RdBu', mag1/mag, sel, bx_vmin, bx_vmax),
            (None, 'Greys', logo, sel, logo_vmin, logo_vmax),
            (None, 'vanimo', logmag, sel, logmag_vmin, logmag_vmax),
        ]):

        if np.prod(data.shape) == 0: continue

        ax = plt.plt.subplot(2,5,ind+1)

        ax.imshow(
            np.where(ect, data, np.nan),
            cmap=cmap,
            vmax=vmax,
            vmin=vmin,
            aspect=aspect,
            origin='lower',
            extent=(0, 1, 0, 1),
        )

        if label is not None:
            ax.set_title(label)

        ax.set_xlim(xmin=0.25, xmax=0.45)
        ax.set_ylim(ymin=0.45, ymax=0.55)

        ax.tick_params(**plt.IMSHOW_TICK_PARAMS)

        plt.plt.setp(ax.get_xticklabels(), visible=False)
        plt.plt.setp(ax.get_yticklabels(), visible=False)

    #---

    nx, ny = mag.shape
    x = (0.5+np.arange(nx)) / nx
    y = (0.5+np.arange(ny)) / ny
    X, Y = np.meshgrid(x, y)

    # plot all extrema
    ax.plot(X[mins], Y[mins], marker='.', markersize=1, color='r', alpha=0.25, linestyle='none')
    ax.plot(X[maxs], Y[maxs], marker='.', markersize=1, color='b', alpha=0.25, linestyle='none')

    # plot minima that we think might be Xs
    ax.plot(X[mins*(data<x_logmag_thr)*(logo>x_logo_thr)], Y[mins*(data<x_logmag_thr)*(logo>x_logo_thr)], marker='x', markersize=4, markeredgewidth=0.75, color='k', alpha=0.5, linestyle='none')

    # plot minima that we think might be Os
    ax.plot(X[mins*(data<o_logmag_thr)*(logo<o_logo_thr)], Y[mins*(data<o_logmag_thr)*(logo<o_logo_thr)], marker='o', markersize=4, markeredgewidth=0.75, markeredgecolor='w', markerfacecolor='none', alpha=0.5, linestyle='none')

    #---

    # finish decorating

    plt.plt.subplots_adjust(
        left=0.01,
        right=0.99,
        bottom=0.05,
        top=0.90,
        hspace=0.03,
        wspace=0.03,
    )

    #---

    return fig

#------------------------

def hist(mins, maxs, sel, mag, o):
    fig = plt.plt.figure(figsize=(5,5))

    ax11 = plt.plt.subplot(2,2,1)
    ax21 = plt.plt.subplot(2,2,3)
    ax22 = plt.plt.subplot(2,2,4)

    #---

    logmag = np.log10(mag)
    logo = np.log10(o)

    #--- define subsets

    everything = np.ones_like(sel, dtype=bool)
    structure = sel

    for ind, (label1, label2, ect) in enumerate([
            ('everything', 'coherent structure', everything),
            ('minima', 'minima in coherent structure', mins),
            ('maxima', 'maxima in coherent structure', maxs),
        ]):

        ectbins = min(100, max(10, int(0.5*np.sum(ect)**0.5)))
        selbins = min(100, max(10, int(0.5*np.sum(sel*ect)**0.5)))

        color = ax21.plot(np.ravel(logmag[ect]), np.ravel(logo[ect]), marker='.', markersize=1, linestyle='none', alpha=0.25)[0].get_color()

        ax21.plot(np.ravel(logmag[ect*sel]), np.ravel(logo[ect*sel]), marker='o', markersize=4, linestyle='none', alpha=0.25, markeredgecolor=color, markerfacecolor='none')

        ax11.hist(np.ravel(logmag[ect]), bins=ectbins, histtype='step', orientation='vertical', log=True, color=color)
        ax11.hist(np.ravel(logmag[ect*sel]), bins=selbins, histtype='stepfilled', orientation='vertical', log=True, color=color, alpha=0.25)

        ax22.hist(np.ravel(logo[ect]), bins=ectbins, histtype='step', orientation='horizontal', log=True, color=color)
        ax22.hist(np.ravel(logo[ect*sel]), bins=selbins, histtype='stepfilled', orientation='horizontal', log=True, color=color, alpha=0.25)

        fig.text(0.95, 0.95-0.03*(2*ind), '%s (%d)' % (label1, np.sum(ect)), color=color, ha='right', va='top', fontsize=8)
        fig.text(0.95, 0.95-0.03*(2*ind+1), '%s (%d)' % (label2, np.sum(ect*sel)), color=color, ha='right', va='top', fontsize=8)

    #---

    fig.text(0.95, 0.95-0.03*(2*ind+2), 'identified X (%d)' % np.sum(mins*(logmag < x_logmag_thr)*(logo > x_logo_thr)), ha='right', va='top', fontsize=8)
    fig.text(0.95, 0.95-0.03*(2*ind+3), 'identified O (%d)' % np.sum(mins*(logmag < o_logmag_thr)*(logo < o_logo_thr)), ha='right', va='top', fontsize=8)

    #---

    ax21.set_xlabel('$\log|B|$')
    ax21.set_ylabel('$\log o$')

    ax11.set_xlim(ax21.get_xlim())
    plt.plt.setp(ax11.get_xticklabels(), visible=False)

    ax22.set_ylim(ax21.get_ylim())
    plt.plt.setp(ax22.get_yticklabels(), visible=False)

    #---

    ylim = ax11.get_ylim()
    ax11.plot([x_logmag_thr]*2, ylim, color='k', alpha=0.25)
    ax11.plot([o_logmag_thr]*2, ylim, color='k', alpha=0.25, linestyle='dashed')
    ax11.set_ylim(ylim)

    xlim = ax22.get_xlim()
    ax22.plot(xlim, [x_logo_thr]*2, color='k', alpha=0.25)
    ax22.plot(xlim, [o_logo_thr]*2, color='k', alpha=0.25, linestyle='dashed')
    ax22.set_xlim(xlim)

    xlim = ax21.get_xlim()
    ylim = ax21.get_ylim()

    ax21.plot([x_logmag_thr, x_logmag_thr, xlim[0]], [ylim[1], x_logo_thr, x_logo_thr], color='k', alpha=0.25)
    ax21.plot([xlim[0], o_logmag_thr, o_logmag_thr], [o_logo_thr, o_logo_thr, ylim[0]], color='k', alpha=0.25, linestyle='dashed')

    ax21.text(xlim[0]+0.05*(xlim[1]-xlim[0]), ylim[1]-0.05*(ylim[1]-ylim[0]), 'X-like', ha='left', va='top')
    ax21.text(xlim[0]+0.05*(xlim[1]-xlim[0]), ylim[0]+0.05*(ylim[1]-ylim[0]), 'O-like', ha='left', va='bottom')

    ax21.set_xlim(xlim)
    ax21.set_ylim(ylim)

    #---

    for ax in fig.axes:
        ax.tick_params(
            left=True,
            right=True,
            top=True,
            bottom=True,
            direction='in',
            which='both',
        )

    plt.plt.subplots_adjust(
        left=0.10,
        right=0.95,
        bottom=0.10,
        top=0.95,
        hspace=0.03,
        wspace=0.03,
    )

    #---

    return fig

#------------------------

def oradius(mag0, mag1, x, y, title=None, delta=50):
    fig = plt.plt.figure(figsize=(5,18))

    ax1 = plt.plt.subplot(6,1,1)
    ax2 = plt.plt.subplot(6,1,2)
    ax3 = plt.plt.subplot(6,1,3)
    ax4 = plt.plt.subplot(6,1,4)
    ax5 = plt.plt.subplot(6,1,5)
    ax6 = plt.plt.subplot(6,1,6)

    #---

    nx, ny = mag0.shape

    kwargs = dict(marker='.', markersize=1, color='k', alpha=0.25, linestyle='none')

    # iterate over everything within this square
    i, j = np.meshgrid(range(max(0, x-delta), min(x+delta, nx)), range(max(0, y-delta), min(y+delta, ny)), indexing='ij')
    i = np.ravel(i)
    j = np.ravel(j)

    sel = np.logical_not((i==x)*(j==y)) # throw away the center point
    i = i[sel]
    j = j[sel]

    # compute displacement vector
    rx = i-x
    ry = j-y
    r = (rx**2 + ry**2)**0.5

    # compute components of mag field in radial and angular directions
    br = (mag0[i,j]*rx + mag1[i,j]*ry) / r
    bt = (mag0[i,j]*(-ry) + mag1[i,j]*rx) / r

    b = (br**2 + bt**2)**0.5

    # add to plots
    ax1.plot(r, b, **kwargs)
    ax2.plot(r, bt, **kwargs)
    ax3.plot(r, br, **kwargs)
    ax4.plot(r, np.abs(br/bt), **kwargs)
    ax5.plot(r, bt/b, **kwargs)
    ax6.plot(r, br/b, **kwargs)

    ax1.plot(0, (mag0[x,y]**2 + mag1[x,y]**2)**0.5, marker='x', markeredgecolor='k', markerfacecolor='none', markersize=4)

    #---

    if title is not None:
        ax1.set_title(title)

    ylim = ax1.get_ylim()
    ax1.fill_between([0, 2**0.5], [ylim[0]]*2, [ylim[1]]*2, color='r', alpha=0.10)
    ax1.set_ylim(ylim)

    ax1.set_ylabel('$|B|$')
    plt.plt.setp(ax1.get_xticklabels(), visible=False)

    ax2.set_ylabel('$B_\\theta$')
    plt.plt.setp(ax2.get_xticklabels(), visible=False)

    ax3.set_ylabel('$B_r$')
    plt.plt.setp(ax3.get_xticklabels(), visible=False)

    ax4.set_yscale('log')
    ax4.set_ylabel('$B_r/B_\\theta$')
    plt.plt.setp(ax4.get_xticklabels(), visible=False)

    ax5.set_ylabel('$B_\\theta/|B|$')
    plt.plt.setp(ax5.get_xticklabels(), visible=False)

    ax6.set_ylabel('$B_r/|B|$')
    ax6.set_xlabel('$r$')

    for ax in fig.axes:
        ax.tick_params(
            left=True,
            right=True,
            top=True,
            bottom=True,
            which='both',
            direction='in',
        )

        ax.set_xlim(xmin=0, xmax=delta*2**0.5)

    plt.plt.subplots_adjust(
        left=0.15,
        right=0.95,
        top=0.95,
        bottom=0.02,
        hspace=0.03,
    )

    #---

    return fig

#-------------------------------------------------

parser = ArgumentParser()

#---

parser.add_argument('inpath', type=str)

#---

parser.add_argument('-w', '--wavelet', type=str, required=True)

parser.add_argument('--denoise', default=5.0, type=float)
parser.add_argument('--max-scale', default=None, type=int)

#---

parser.add_argument('-o', '--output-dir', default='.', type=str)
parser.add_argument('-t', '--tag', default='', type=str)

parser.add_argument('--figtype', default=[], type=str, action='append')
parser.add_argument('--dpi', default=200, type=float)

#---

parser.add_argument('-v', '--verbose', default=False, action='store_true')
parser.add_argument('-V', '--Verbose', default=False, action='store_true')

#---

args = parser.parse_args()

os.makedirs(args.output_dir, exist_ok=True)

if args.tag:
    args.tag = "_"+args.tag

if not args.figtype:
    args.figtype.append('png')

args.verbose |= args.Verbose

#-------------------------------------------------

basename = os.path.basename(args.inpath).split('.')[0] # used to construct output figure names

#-------------------------------------------------

# load magnetic field data

if args.verbose:
    print('loading magnetic field from: '+args.inpath)
mag = np.load(args.inpath)
_, nx, ny = mag.shape

#------------------------

# compute derived quantities

dvf = dv.DerivedVars(num_of_dims=2, bcs="00")

#-----------

# take the curl to get the current

if args.verbose:
    print('computing curr = curl(mag)')

curr = dvf.vector_curl(mag)
curr_ha = pywt.WaveletArray(curr, args.wavelet)

if args.Verbose:
    print('    denoising with thr=%.3f' % args.denoise)
curr_ha.denoise(args.denoise, max_scale=args.max_scale)

#-----------

if args.verbose:
    print('    computing gradient of magnetic field')
grad_mag = dvf.gradient_tensor(mag)

det = grad_mag[0,0]*grad_mag[1,1] - grad_mag[0,1]*grad_mag[1,0] # determinant of dBi/dxj
div = grad_mag[0,0] + grad_mag[1,1] # divergence: \sum_i dBi/dxi

#-----------

if args.verbose:
    print('    computing magnetic field magnitude')
abs_mag = np.sum(mag**2, axis=0)**0.5 # take the magnitude of the magnetic field vector

if args.verbose:
    print('    finding local extrema of magnetic field magnitude')
mins, maxs = extrema(abs_mag)

#-----------

if args.verbose:
    print('    computing test statistic for rotation symmetry')
o = np.empty((nx, ny), dtype=float)
o[0,:] = o[-1,:] = o[:,0] = o[:,-1] = np.nan # turn the edge points off

p = np.empty((nx, ny), dtype=float)
p[0,:] = p[-1,:] = p[:,0] = p[:,-1] = np.nan

### FIXME: change this to look at btheta vs br? or add another stat to capture that?

for i in range(nx-2): # iterate through all points and test for symmetry in rotations of pi/2
    for j in range(ny-2):

        # compare the effect of rotating the field
        o[i+1,j+1] = \
            + (mag[0,i+1,j+2] - mag[1,i,j+1])**2 \
            + (mag[0,i+1,j+2] + mag[1,i+2,j+1])**2 \
            + (mag[0,i+1,j] - mag[1,i+2,j+1])**2 \
            + (mag[0,i+1,j] + mag[1,i,j+1])**2 \

        # compare the size of B_theta and B_r
        p[i+1,j+1] = \
            + np.abs(mag[0,i+1,j+2]/abs_mag[i+1,j+2]) \
            + np.abs(mag[1,i+2,j+1]/abs_mag[i+2,j+1]) \
            + np.abs(mag[0,i+1,j]/abs_mag[i+1,j]) \
            + np.abs(mag[1,i,j+1]/abs_mag[i,j+1]) \

o /= abs_mag**2 # scale these by the size of the magnetic field at the center point

#-------------------------------------------------

# let's make some plots
if args.verbose:
    print('plotting')

# imshow of various fields with annotations
#fig = imshow(curr, curr_ha.array, abs_mag, mag[0], mag[1], o, div, det, mins, maxs, aspect='auto')
fig = imshow(curr, curr_ha.array, abs_mag, mag[0], mag[1], p, div, det, mins, maxs, aspect='auto')

figtmp = os.path.join(
    args.output_dir,
    '%s_magic-imshow%s' % \
        (basename, args.tag),
) + '.%s'

plt.save(fig, figtmp, args.figtype, dpi=args.dpi, verbose=args.verbose)
plt.close(fig)

#------------------------

# histograms of selection criteria
#fig = hist(mins, maxs, np.abs(curr_ha.array > 0), abs_mag, o)
fig = hist(mins, maxs, np.abs(curr_ha.array > 0), abs_mag, p)

figtmp = os.path.join(
    args.output_dir,
    '%s_magic-hist%s' % \
        (basename, args.tag),
) + '.%s'

plt.save(fig, figtmp, args.figtype, dpi=args.dpi, verbose=args.verbose)
plt.close(fig)

#------------------------

# plot radial dependence of mag centered on O points

_, nx, ny = mag.shape
x = np.arange(nx)
y = np.arange(ny)
X, Y = np.meshgrid(x, y, indexing='ij')

o_cent = mins*(np.log10(abs_mag) < o_logmag_thr)*(np.log10(o) < o_logo_thr)

Xo = X[o_cent]
Yo = Y[o_cent]

for ind, (x, y) in enumerate(zip(Xo, Yo)):
    title = '(x, y) = (%d, %d)\n$\log o = %.3f$\n$\log|B| = %.3f$' % (x, y, np.log10(o[x,y]), np.log10(abs_mag[x,y]))

    fig = oradius(mag[0], mag[1], x, y, delta=100, title=title)

    figtmp = os.path.join(
        args.output_dir,
        '%s_magic-oradius-%06d%s' % \
            (basename, ind, args.tag),
    ) + '.%s'

    plt.save(fig, figtmp, args.figtype, dpi=args.dpi, verbose=args.verbose)
    plt.close(fig)

#!/usr/bin/env python3

"""a simple testing script to figure out syntax and which calculations are useful
"""
__author__ = "Reed Essick (reed.essick@gmail.com)"

#-------------------------------------------------

import numpy as np

from argparse import ArgumentParser

### non-standard libraries
try:
    from PLASMAtools.read_funcs.read import Fields
except ImportError:
    Fields = None

from w4t import haar

#-------------------------------------------------

parser = ArgumentParser()

parser.add_argument('--path', type=str, default=None,
    help='path to an HDF file containing simulation data')

parser.add_argument('-n', '--num-grid', type=int, default=32,
    help='the number of grid points used when constructing random data instead of reading from --path')

parser.add_argument('-f', '--field', required=True, default=[], type=str, action='append',
    help='load and manipulate this field. Can be repeated. eg, --field vel --field mag --field dens')

parser.add_argument('-v', '--verbose', default=False, action='store_true')

args = parser.parse_args()

#-------------------------------------------------

data = dict()

if args.path is not None: # read data from file
    if args.verbose:
        print('loading: '+args.path)

    if Fields is None:
        raise ImportError('could not import PLASMAtools.read_funcs.read.Fields')

    turb = Fields(args.path, reformat=True)

    # read the fields
    for field in args.field:
        turb.read(field)
        data[field] = getattr(turb, field) # replacement for this syntax: turb.vel

    del turb # get rid of this object to save memory

else: # generate random data on a big-ish 3D array

    shape = (1,)+(args.num_grid,)*3
    if args.verbose:
        print('generating randomized data with shape: %s' % (shape,))

    for field in args.field:
        data[field] = np.random.random((1,)+(args.num_grid,)*3)

    ### FIXME: consider adding Gaussian noise on top of some sort of coherent structure?

#---

if args.verbose:
    print('    '+field, data[field].shape) # expect [num_dim, num_x, num_y, num_z]

#-------------------------------------------------

# compute Haar decomposition of all fields

for field in args.field:
    if args.verbose:
        print('testing Haar decomposition of: '+field)

    #---

    # basic instantiation
    ha = haar.HaarArray(data[field][0]) # FIXME: only grab the first element for now

    print(ha.array)
    print('ndim', ha.ndim)
    print('shape', ha.shape)

    print('active', ha.active)
    print('levels', ha.levels)
    print('scales', ha.scales)
    print('wavenumbers', ha.wavenumbers)

    #---

    # 1D decompositions
    for axis in range(3):
        print('--- axis=%d' % axis)

        # try taking decompositions
        ha.haar(axis=axis)

        print(ha.array)
        print('active', ha.active)
        print('levels', ha.levels)
        print('scales', ha.scales)
        print('wavenumbers', ha.wavenumbers)

        # try taking inverse decompositions
        ha.ihaar(axis=axis)

        print(ha.array)
        print('active', ha.active)
        print('levels', ha.levels)
        print('scales', ha.scales)
        print('wavenumbers', ha.wavenumbers)

    #---

    # automatic decompositions
    print('--- all axes')

    print('HAAR 0')
    print(ha.array)
    print('levels', ha.levels)
    print('active', ha.active)

    ha.haar()

    print('HAAR 1')
    print(ha.array)
    print('active', ha.active)
    print('levels', ha.levels)
    print('scales', ha.scales)
    print('wavenumbers', ha.wavenumbers)

    ha.haar()

    print('HAAR 2')
    print(ha.array)
    print('active', ha.active)
    print('levels', ha.levels)
    print('scales', ha.scales)
    print('wavenumbers', ha.wavenumbers)

    ha.ihaar()

    print('HAAR 1')
    print(ha.array)
    print('active', ha.active)
    print('levels', ha.levels)
    print('scales', ha.scales)
    print('wavenumbers', ha.wavenumbers)

    ha.ihaar()
    print('HAAR 0')
    print(ha.array)
    print('active', ha.active)
    print('levels', ha.levels)
    print('scales', ha.scales)
    print('wavenumbers', ha.wavenumbers)

    #---

    print('--- decompose')

    ha.decompose()

    print(ha.array)
    print('active', ha.active)
    print('levels', ha.levels)
    print('scales', ha.scales)
    print('wavenumbers', ha.wavenumbers)

    ha.idecompose()

    print(ha.array)
    print('active', ha.active)
    print('levels', ha.levels)
    print('scales', ha.scales)
    print('wavenumbers', ha.wavenumbers)

    #---

    raise NotImplementedError('''
make some basic visualizations

at each resolution/scale

    2D figures
        imshow of slices (step through in all directions?)

    3D figures
        vector --> quiver
        scalar --> scatter with color to indicate intensity?
''')

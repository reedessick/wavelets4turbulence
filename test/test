#!/usr/bin/env python3

"""a simple testing script to figure out syntax and which calculations are useful
"""
__author__ = "Reed Essick (reed.essick@gmail.com)"

#-------------------------------------------------

import numpy as np

import matplotlib
matplotlib.use("Agg")
from matplotlib import pyplot as plt
plt.rcParams['text.usetex'] = True

from argparse import ArgumentParser

### non-standard libraries
try:
    from PLASMAtools.read_funcs.read import Fields
except ImportError:
    Fields = None

from w4t import haar

#-------------------------------------------------

parser = ArgumentParser()

parser.add_argument('--path', type=str, default=None,
    help='path to an HDF file containing simulation data')

parser.add_argument('-n', '--num-grid', type=int, default=32,
    help='the number of grid points used when constructing random data instead of reading from --path')

parser.add_argument('-f', '--field', required=True, default=[], type=str, action='append',
    help='load and manipulate this field. Can be repeated. eg, --field vel --field mag --field dens')

parser.add_argument('-v', '--verbose', default=False, action='store_true')

args = parser.parse_args()

#-------------------------------------------------

data = dict()

if args.path is not None: # read data from file
    if args.verbose:
        print('loading: '+args.path)

    if Fields is None:
        raise ImportError('could not import PLASMAtools.read_funcs.read.Fields')

    turb = Fields(args.path, reformat=True)

    # read the fields
    for field in args.field:
        turb.read(field)
        data[field] = getattr(turb, field) # replacement for this syntax: turb.vel

    del turb # get rid of this object to save memory

else: # generate random data on a big-ish 3D array

    shape = (1,)+(args.num_grid,)*3
    if args.verbose:
        print('generating randomized data with shape: %s' % (shape,))

    for field in args.field:
#        data[field] = np.random.random((1,)+(args.num_grid,)*3)
        data[field] = np.random.normal(size=(1,)+(args.num_grid,)*3)

    ### FIXME: consider adding Gaussian noise on top of some sort of coherent structure?

#---

if args.verbose:
    print('    '+field, data[field].shape) # expect [num_dim, num_x, num_y, num_z]

#-------------------------------------------------

# compute Haar decomposition of all fields

for field in args.field:
    if args.verbose:
        print('testing Haar decomposition of: '+field)

    #---

    if len(data[field] > 1) and args.verbose:
        print('WARNING: only examining index 0 of field')

    # basic instantiation
    ha = haar.HaarArray(data[field][0])

    print(ha.array)
    print('ndim', ha.ndim)
    print('shape', ha.shape)

    print('active', ha.active)
    print('levels', ha.levels)
    print('scales', ha.scales)
    print('wavenumbers', ha.wavenumbers)

    #---

    # 1D decompositions
    for axis in range(3):
        print('--- axis=%d' % axis)

        # try taking decompositions
        ha.haar(axis=axis)

        print(ha.array)
        print('active', ha.active)
        print('levels', ha.levels)
        print('scales', ha.scales)
        print('wavenumbers', ha.wavenumbers)

        # try taking inverse decompositions
        ha.ihaar(axis=axis)

        print(ha.array)
        print('active', ha.active)
        print('levels', ha.levels)
        print('scales', ha.scales)
        print('wavenumbers', ha.wavenumbers)

    #---

    # automatic decompositions
    print('--- all axes')

    print('HAAR 0')
    print(ha.array)
    print('levels', ha.levels)
    print('active', ha.active)

    ha.haar()

    print('HAAR 1')
    print(ha.array)
    print('active', ha.active)
    print('levels', ha.levels)
    print('scales', ha.scales)
    print('wavenumbers', ha.wavenumbers)

    ha.haar()

    print('HAAR 2')
    print(ha.array)
    print('active', ha.active)
    print('levels', ha.levels)
    print('scales', ha.scales)
    print('wavenumbers', ha.wavenumbers)

    ha.ihaar()

    print('HAAR 1')
    print(ha.array)
    print('active', ha.active)
    print('levels', ha.levels)
    print('scales', ha.scales)
    print('wavenumbers', ha.wavenumbers)

    ha.ihaar()
    print('HAAR 0')
    print(ha.array)
    print('active', ha.active)
    print('levels', ha.levels)
    print('scales', ha.scales)
    print('wavenumbers', ha.wavenumbers)

    #---

    print('--- decompose')

    ha.decompose()

    print(ha.array)
    print('active', ha.active)
    print('levels', ha.levels)
    print('scales', ha.scales)
    print('wavenumbers', ha.wavenumbers)

    ha.idecompose()

    print(ha.array)
    print('active', ha.active)
    print('levels', ha.levels)
    print('scales', ha.scales)
    print('wavenumbers', ha.wavenumbers)

    #--------------------

    # make quiver plots in 3D
    # NOTE: assumes all grid dimensions have the same number of points, which could be fragile

    if args.verbose:
        print('plotting')

    while ha.active[0] > 1: # keep decomposing

        a = ha.approx # grab coefficients
        d = ha.detail

        #---

        # FIXME: make 2D scans

        #---

        # make 3D scatter plot

        fig = plt.figure()

        xs = np.arange(ha.active[0]) # NOTE this could be fragile
        xs, ys, zs = np.meshgrid(xs, xs, xs, indexing='ij')
    
        if len(a):    
            ax1 = fig.add_subplot(2, 2, 1, projection='3d')
            cs = (a-np.min(a)) / (np.max(a)-np.min(a))
            ax1.scatter(xs.flatten(), ys.flatten(), zs.flatten(), marker='.', c=cs.flatten(), alpha=0.25)
            ax1.set_title('approx')

            AX1 = fig.add_subplot(2, 2, 3)
            AX1.hist(a.flatten(), bins=max(10, int(0.5*np.prod(a.shape)**0.5)), histtype='step')

        if len(d):
            ax2 = fig.add_subplot(2, 2, 2, projection='3d')
            cs = (d-np.min(d)) / (np.max(d)-np.min(d))
            ax2.scatter(xs.flatten(), ys.flatten(), zs.flatten(), marker='.', c=cs.flatten(), alpha=0.25)
            ax2.set_title('detail')

            AX2 = fig.add_subplot(2, 2, 4)
            AX2.hist(d.flatten(), bins=max(10, int(0.5*np.prod(d.shape)**0.5)), histtype='step')

        #---

        figname = 'test-quiver-%s.png' % ('-'.join('%03d'%_ for _ in ha.scales))
        if args.verbose:
            print('    saving: '+figname)
        fig.savefig(figname)
        plt.close(fig)

        #---

        ha.haar()

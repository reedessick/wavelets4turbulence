#!/usr/bin/env python3

import numpy as np
import copy
from w4t.pywt import WaveletArray

import time

#-------------------------------------------------

np.random.seed(123)

#-------------------------------------------------

data = np.random.normal(size=(80,)*3)

ha = WaveletArray(data, 'haar')

#------------------------

thr = 1.0
sel = np.abs(ha.approx) > thr
print(sel)

#------------------------

print('testing ability to select a pixel from a boolean array')

pix = ha._sel2pix(sel)
print(pix)

#------------------------

print('testing ability to identify neighbors')

neighbors = ha._pix2neighbors(pix, ha._shape2shifts(sel.shape), sel.shape)
print('neighbors')
for neighbor in neighbors:
    print('    ', neighbor)

#------------------------

print('testing ability to find a cluster that includes a pixel')

cluster, new = ha._pix2cluster(pix, copy.copy(sel), ha._shape2shifts(sel.shape))
print(sel)
print(new)
print('cluster')
for _ in cluster:
    print('    ', _)

#------------------------

print('testing ability to find all clusters')

clusters = ha._structures(copy.copy(sel))

for cnd, cluster in enumerate(clusters):

#    print('cluster %d' % cnd)
#    for _ in cluster:
#        print('    ', _)
#
#    print(sel[tuple(np.transpose(cluster))])

    if len(cluster) > 1:
        for ind in range(len(cluster)):
            dist = np.sum((cluster[ind]-cluster)**2, axis=1)
            dist = list(dist[:ind])+list(dist[ind+1:])
            assert np.min(dist) <= ha.ndim

            if cnd < len(clusters)-1:
                ance = [np.min(np.sum((cluster[ind]-other)**2, axis=1)) for other in clusters[cnd+1:]]
                assert np.min(ance) > ha.ndim

#------------------------

# test multiprocessing

print('testing multiprocessing')

t0 = time.time()
sc = ha.structures(thr=thr)
print('single-core structure identification:', time.time()-t0)

t0 = time.time()
mp = ha.structures(thr=thr, num_proc=4)
print('multiprocessing structure identification:', time.time()-t0)

for dim in range(ha.ndim):
    sc = [struc[np.argsort(struc[:,-(dim+1)])] for struc in sc] # order the indiv pixels within each structure
    sc.sort(key=lambda x:x[0,-(dim+1)]) # order structures

    mp = [struc[np.argsort(struc[:,-(dim+1)])] for struc in mp] # order the indiv pixels within each structure
    mp.sort(key=lambda x:x[0,-(dim+1)]) # order structures

assert len(sc) == len(mp), 'identified different numbers of structures'

for ind in range(len(sc)):

    for jnd, pix in enumerate(sc[ind]):
        if np.any(np.all(pix==sc[ind][jnd+1:], axis=1)):
            raise RuntimeError('pix repeated in sc!', pix)

    for jnd, pix in enumerate(mp[ind]):
        if np.any(np.all(pix==mp[ind][jnd+1:], axis=1)):
            raise RuntimeError('pix repeated in mp!', pix)

    assert len(sc[ind]) == len(mp[ind]), 'identified structures contain different numbers of pixels'

    for pix in sc[ind]:
        assert np.sum(np.all(pix==mp[ind], axis=1)) == 1, 'pixel mismatch or repeated pixel'
